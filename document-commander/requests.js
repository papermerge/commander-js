import { Collection } from "@papermerge/symposium";
import { Folder, Document } from "./models/index";
import { OcrLang } from "./models/ocr_lang";
import { urlconf } from "./urls";
import { settings } from "./conf";


function fetch_folder(folder) {
    /**
     Fetches children of given folder via ajax request.

    `folder` parameter can be either `undefined` or an instance of
     `models.folder.Folder` class.
    In case `folder` is `undefined` function will retrieve
    children of the root folder i.e. top most documents and folders
    for currently logged in user.

    Reponse is expected to be a json in following format:
        {
            'current_nodes': [
                {id, title, model},  # i.e. { id: some_id, title: some_tile, ... }
                {id, title, model},
                ...
            ]
        }

    'current_nodes' is an array of dictionaries with following keys:
        - id
        - title
        - model
    Notice that `model` key will be either 'document' or 'folder' depending
    of the type of node.
    */
    let options,
        response,
        promise,
        url,
        folder_dict;

    options = {
        'headers': {
            'Content-Type': 'application/json'
        }
    }

    if (folder && folder.id) {
        url = urlconf.url('folder' , {
            folder_id: folder.id
        });
    } else if (folder) {
        url = urlconf.url('folder' , {
            folder_id: folder
        });
    } else {
        url = urlconf.url('folder');
    }

    response = fetch(url, options).then((response) => {
        if (response.status != 200) {
            throw new Error(response.statusText);
        }
        // response.json() returns a Promise!
        return response.json();
    }).then(json_response => {
        let nodes = new Collection(),
            breadcrumb_col,
            folders_arr,
            current_nodes;

        current_nodes = json_response['current_nodes'].map((item_attrs) => {
            if (item_attrs['model'] == 'document') {
                return new Document(item_attrs);
            } else {
                return new Folder(item_attrs);
            };
        });
        if (json_response['breadcrumb']) {
            breadcrumb_col = new Collection();
            folders_arr = json_response['breadcrumb'].map((item_attrs) => {
                return new Folder(item_attrs);
            });
            breadcrumb_col.add(folders_arr);
        }
        nodes.add(current_nodes);

        return {nodes: nodes, breadcrumb: breadcrumb_col};
    });

    return response;
} // fetch_folder

function fetch_ocr_langs() {
    let options,
        response,
        promise;

    options = {
        'headers': {
            'Content-Type': 'application/json'
        }
    }
    response = fetch(urlconf.url('ocr_langs'), options).then((response) => {
        if (response.status != 200) {
            throw new Error(response.statusText);
        }
        // response.json() returns a Promise!
        return response.json();
    }).then(json_response => {
        let ocr_langs = new Collection();

        ocr_langs = json_response['ocr_langs'].map((item_attrs) => {
            return new OcrLang(item_attrs);
        });

        return ocr_langs;
    });

    return response;
}

function create_new_folder({title, parent}) {
    let options,
        response,
        promise,
        data = {},
        csrf_selector,
        csrf_header,
        token;

    data = {
        'title': title,
        'parent_id':  parent && parent.id
    };

    options = {
        'headers': {
            'Content-Type': 'application/json',
        },
        'method': 'POST',
        'body': JSON.stringify(data)
    }

    csrf_selector = settings.get('csrf-selector');
    csrf_header = settings.get('csrf-header');

    if (csrf_selector) {
        token = document.querySelector(csrf_selector);
        if (!token) {
            console.warn("CSRF token DOM element not found");
        } else {
            // set csrf header to token generated by django backend
            options['headers'][csrf_header] = token.value;
        }
    } else {
        console.warn("CSRF selector not found");
    }

    response = fetch(urlconf.url('folder_add'), options).then((response) => {
        if (response.status != 200) {
            throw new Error(response.statusText);
        }
        // response.json() returns a Promise!
        return response.json();
    });

    return response;
}

function download_document(doc) {
    let url;

    url = urlconf.url('document_download', {document_id: doc});

    fetch(url).then(
        res => res.blob()
    ).then( blob => {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');

        a.style.display = 'none';
        a.href = url;
        // the filename you want
        a.download = doc.title;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
    });
}

export {
    fetch_folder,
    fetch_ocr_langs,
    create_new_folder,
    download_document
};